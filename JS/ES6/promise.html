<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // promise
        const p = new Promise(function (resolve, reject) {
            setTimeout(function () {
                // let data = '数据库中的数据';
                // resolve
                // resolve(data); //成功
                let err = '数据读取失败';
                // reject
                reject(err)
            }, 3000)
        })

        // 调用 promise 对象的 then 方法
        p.then(function (value) {
            console.log(value)
        }, function (reason) {
            console.error(reason)
        })

        const p1 = new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            //设置接受类型
            // xhr.responseType = 'json';
            //超时设置
            // xhr.timeout = 2000;
            //超时回调
            // xhr.ontimeout = function(){
            //     alert('请求超时,请稍后重试');
            // }
            // 初始化 设置请求方法和url
            xhr.open('GET', 'http://127.0.0.1:8000/server');
            // 发送
            xhr.send();
            //取消请求
            // xhr.abort();
            //绑定事件,处理服务端返回的结果
            xhr.onreadystatechange = function () {
                // 服务端返回了所有结果
                if (xhr.readyState === 4) {
                    // 判断响应状态 200 404 403 401 500
                    if (xhr.status === 200) {
                        // 处理结果
                        // console.log(xhr.status);//状态码
                        // console.log(xhr.statusText);//状态字符串
                        // console.log(xhr.getAllResponseHeaders);//所有响应头
                        // console.log(xhr.response)//响应体
                        // request.innerHTML = xhr.response.name;
                        request.innerHTML = xhr.response;
                        resolve(xhr.response);
                    } else {
                        reject(xhr.status);
                    }
                }
            }
        })

        p1.then(function (value) {
            console.log(value)
        }, function (reason) {
            console.error(reason)
        })
        // Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
        p1.catch(function (reason) {
            console.error(reason)
        })
        // Promise.finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

        // Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
        // const p = Promise.all([p1, p2, p3]);
        // 生成一个Promise对象的数组
        const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
            return getJSON('/post/' + id + ".json");
        });

        Promise.all(promises).then(function (posts) {
            // ...
        }).catch(function (reason) {
            // ...
        });
        const p2 = new Promise(function (resolve, reject) {
            resolve('成功的数据');
        });
        // Promise.allSettled 永远是成功, 存放多个promise组成的数组；
        const resultAll1 = Promise.allSettled([p1, p2]);
        console.log(resultAll1);

        // Promise.all 全部成功才是成功
        const resultAll2 = Promise.all([p1, p2]);
        console.log(resultAll2);

        // Promise.race()
        // const p = Promise.race([p1, p2, p3]);
        // 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。

        // Promise.any()
        //只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。

        // Promise.resolve() , 将现有对象转为 Promise 对象


        //  async-----------------------------------------------------------------------
        
        // async 函数返回 promise对象,结果由async函数执行的返回值决定
        async function fn() {
            //return结果不是 promise 类型的对象，则返回结果就是成功 promise对象
            // return '学习'; //fulfille

            //抛出错误, 返回结果是一个失败的Promise
            // throw new Error('失败啦!'); // rejected

            //返回结果是一个promise对象 async对象返回结果与返回的promise状态一致
            return new Promise((resolve, reject) => {
                resolve('成功了');
                // reject('失败了');
            })

        }
        const result = fn();
        result.then(value => {
            console.log(value);
        }, reason => {
            console.log(reason)
        })

        // await必须写在 async 函数中
        // await右侧表达式一般为promise对象
        // await返回的是promise成功的值, 如果失败, 就会抛出异常,需要try...catch 捕获处理
        async function main() {
            let result = await p2;
            console.log(result);
        }
        main();

    </script>
</body>

</html>